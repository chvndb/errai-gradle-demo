import java.nio.file.Files
import java.nio.file.Paths

buildscript {
  ext.overridable = { prop, defaultVal ->
    hasProperty(prop) ? getProperty(prop) : defaultVal
  }

  ext.exec = { cmd ->
    cmd.execute().text.trim()
  }

  ext.versions = [ gmd: [:] ]
  versions.gwt          =   "2.8.0"
  versions.errai        =   "4.0.0.CR1"
  versions.gmd.core     =   "2.0-rc3"
  versions.gmd.jquery   =   "1.0-rc3"
  versions.gmd.table    =   "1.0-rc3"

  ext.gwt =  [ modules: [:], dir: [:], log: [:] ]
  gwt.workers           =   "2"
  gwt.modules.dev       =   "demo.errai.App"
  gwt.modules.prod      =   "demo.errai.App"
  gwt.dir.build         =   "${buildDir}/gwt"
  gwt.dir.deps          =   "${gwt.dir.build}/deps"
  gwt.dir.input         =   "${gwt.dir.build}/input"
  gwt.dir.output        =   "${gwt.dir.build}/output"
  gwt.dir.extra         =   "${gwt.dir.build}/extra"
  gwt.dir.dev           =   "${gwt.dir.build}/dev"
  gwt.dir.unitcache     =   "${gwt.dir.build}/unitcache"
  gwt.log.dev           =   overridable("gwtLogDev", "INFO")
  gwt.log.prod          =   overridable("gwtLogProd", "INFO")

  ext.errai =  [ dir: [:] ]
  errai.dir.work        =   "${projectDir}/.errai"
  errai.dir.build       =   "${buildDir}/errai"
  errai.dir.output      =   "${errai.dir.build}/output"

  ext.deploy =  [ dir: [:] ]
  deploy.dir.war        =   "${projectDir}/war"
  deploy.dir.app        =   "${deploy.dir.war}/${name}.war"
}

apply plugin: "war"
apply plugin: "eclipse"

repositories {
  mavenCentral()
}

dependencies {
  providedCompile "com.google.gwt:gwt-user:$versions.gwt"
  providedCompile "com.google.gwt:gwt-dev:$versions.gwt"
  runtime "com.google.gwt:gwt-servlet:$versions.gwt"

  compile "org.jboss.errai:errai-javaee-all:$versions.errai"
  compile "org.jboss.errai:errai-jboss-as-support:$versions.errai"

  providedCompile "com.github.gwtmaterialdesign:gwt-material:$versions.gmd.core"
  providedCompile "com.github.gwtmaterialdesign:gwt-material-addins:$versions.gmd.core"
  providedCompile "com.github.gwtmaterialdesign:gwt-material-themes:$versions.gmd.core"
  providedCompile "com.github.gwtmaterialdesign:gwt-material-jquery:$versions.gmd.jquery"
  providedCompile "com.github.gwtmaterialdesign:gwt-material-table:$versions.gmd.table"
}

clean.doFirst {
  delete errai.dir.work
  delete deploy.dir.war
}

// [WINDOWS]
//  A shell command has a limited maximum size.
//  Deep dependency chains require large paths for gwt{Compiler,CodeServer}.
//  Therefore, soft symbolic links are generated to all the dependencies.
//  The output directory can then be added to the classpath.
// [NOTE]
//  Soft symbolic links are used because Windows NTFS does not allow hard links
//  to be removed when in use. Hard links cause build failures as the Gradle daemon keeps a
//  reference to the files it copies. This blocks the deamon from overwriting them in a subsequent build.
// [WARNING]
//  To create symbolic links in Windows, the shell needs to be run with administator privileges,
//  _even_ if you're a user with administrator privileges.
task gwtDependencies() {
  inputs.files configurations.compile
  inputs.files configurations.providedCompile
  outputs.dir gwt.dir.deps
  doFirst { file(gwt.dir.deps).mkdirs() }
  doLast {
    def target = Paths.get(gwt.dir.deps)
    def deps = configurations.compile.files + configurations.providedCompile.files
    def valid = deps.collect { file -> createSymbolicLink(file.toPath(), target) }
    // Remove dependencies which no longer exist. Having this avoids the need to depend on task
    // "clear", but still correctly recognizes when dependencies have been removed and a
    // recompile should be triggered.
    fileTree(gwt.dir.deps).minus(valid).each { file ->
      logger.debug("Removed unreferenced cached dependency: " + file)
      delete file
    }
  }
}

def createSymbolicLink(def origin, def target) {
  def fileName = origin.fileName
  def link = target.resolve(fileName)
  // [WARNING] dependencies with the same filename but different content will be skipped because of this.
  if(!link.toFile().exists())
    Files.createSymbolicLink(link, origin)
  link.toFile()
}

// Merge GWT inputs (source, classes, resources) to ensure Errai required property files are picked
// up correctly, e.g. ErraiApp.propeties, and Errai generators are triggered.
task gwtClasses(type: Copy, dependsOn: classes) {
  includeEmptyDirs false
  from sourceSets.main.output.resourcesDir
  from(sourceSets.main.java.srcDirs) {
    include "**/**.gwt.xml"
    include "**/client/**"
    include "**/shared/**"
  }
  from(sourceSets.main.output.classesDir) {
    include "**/client/**"
    include "**/shared/**"
  }
  into gwt.dir.input
}

// [WINDOWS]
//  The classpath closure of the JavaExec task can not be used, because it
//  refuses to accept directory wildcards in Windows.
//  This would generate a "Could not normalize path" error.
//  Therefore, the classpath must be provided as a JVM argument using "--classpath"
def gwtClasspath() {
  [gwt.dir.input, "${gwt.dir.deps}/*"].flatten().join(":")
}

task gwtCompile(type: JavaExec, dependsOn: [gwtClasses, gwtDependencies]) {
  main = "com.google.gwt.dev.Compiler"
  jvmArgs = ["-classpath", gwtClasspath()]
  maxHeapSize = "1024M"
  inputs.files(gwtClasses.destinationDir).skipWhenEmpty()
  inputs.files gwtDependencies.destinationDir
  outputs.dir gwt.dir.output
  args = [
    gwt.modules.prod,
    "-war", gwt.dir.output,
    "-logLevel", gwt.log.prod,
    "-localWorkers", gwt.workers,
    "-failOnError",
    "-generateJsInteropExports",
    "-extra", gwt.dir.extra
  ].flatten()
  // Avoid generated errai classes to be added to the build/classes folder
  // which in turn would trigger a redundant recompile even when nothing changes.
  // [NOTE] The generated classes need be added to the final WAR.
  systemProperties["errai.server.classOutput"] = errai.dir.output
}

war.dependsOn gwtCompile
war {
  includeEmptyDirs false
  from gwt.dir.output                                // include GWT generated output files
  from (errai.dir.output) { into "WEB-INF/classes" } // include Errai generated output files
  rootSpec.exclude("**/client/**")                   // exclude GWT specific client-side java source code
}

task gwtDev(type: JavaExec, dependsOn: gwtCompile) {
  main = "com.google.gwt.dev.codeserver.CodeServer"
  jvmArgs = ["-classpath", gwtClasspath()]
  doFirst { file(gwt.dir.dev).mkdirs() }
  args = [
    gwt.modules.dev,
    "-logLevel", gwt.log.dev,
    "-launcherDir", deploy.dir.app,
    "-workDir", gwt.dir.dev,
    "-style", "Pretty",
    "-generateJsInteropExports",
    "-bindAddress", "0.0.0.0"
  ].flatten()
  systemProperties["gwt.persistentunitcachedir"] = gwt.dir.unitcache
}

task redeploy(type: Copy, dependsOn: war) {
  doFirst { file(deploy.dir.app).mkdirs() }
  doFirst { delete deploy.dir.app }
  into deploy.dir.app
  with war
}

task stop {
  doLast { exec("docker-compose -f src/main/docker/wildfly.yml down") }
}

task start(dependsOn: stop) {
  doFirst { file(deploy.dir.app).mkdirs() }
  doLast { exec("docker-compose -f src/main/docker/wildfly.yml up -d") }
  finalizedBy redeploy
}
